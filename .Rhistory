# Définir le répertoire de travail comme celui du script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
decathlon<-read.table("./decathlon/decathlon.txt",
stringsAsFactors = TRUE)
# On effectue l’ACP en calculant toutes les composantes
library(FactoMineR)
res.pca <- PCA(decathlon,
quanti.sup = c(11: 12),
quali.sup = c(13),
graph = FALSE,
scale.unit = TRUE,
ncp = Inf)
# Spécifier ncp=Inf sinon seules les 5 premières composantes seront déterminées.
# Spécifier ncp=Inf sinon seules les 5 premières composantes seront déterminées.
# A ce stade, on ne sait pas encore quel est le nombre de composantes à utiliser pour la classification.
#valeurs propres
res.pca$eig
# => nécessaire d’utiliser 7 composantes pour utiliser 90% de l’information, 10 pour ne perdre aucune information.
barplot(res.pca$eig[,1], las = 2)
# Le diagramme des valeurs propres suggérerait d’utiliser 8 composantes (saut entre les valeurs propres 8 et 9).
# On retient 8 composantes afin de conserver une grande quantité d’inertie de projection.
# On relance donc l’ACP avec 8 composantes et on utilise par la suite la sortie obtenue pour effectuer la classification.
res.pca <- PCA(decathlon,
quanti.sup = c(11: 12),
quali.sup = c(13),
graph = FALSE,
scale.unit = TRUE,
ncp = 8)
# CAH selon la méthode de Ward, classique pour des distances euclidiennes
# car elle consiste à optimiser un critère d’inertie intra-classe ou inter-classes,
# définissant une “bonne classification”.
library(cluster)
res.agnes <- agnes(res.pca$ind$coord, method = "ward")
plot(res.agnes, main = "Dendogramme", xlab = "Individus", which.plots = 2)
# => découpage en 4 classes
# Confirmer avec le diagramme des gains d’inertie.
barplot(sort(res.agnes$height, decreasing = TRUE),
las = 2,
names.arg = 1:40,
xlab = "index",
ylab = "hauteur de fusion")#les hauteurs de fusions (contenues dans l'objet res.agnes$height) ne sont pas rangées dans l'ordre, on les trie à l'aide de la fonction sort par ordre decroissant (decreasing=TRUE) avant de les représenter à l'aide de la fonction barplot
# classification par k-means avec 4 centres et 100 initialisations différentes
classe <- kmeans(res.pca$ind$coord,
centers = 4,
nstart = 100)
# Choix du nombre de classes par rapport aux résultats fournis par la CAH
# Autre possibilité : considérer plusieurs nombres de classes et rechercher
# un coude dans le diagramme des inerties intra-classe.
# Ici on inspecte un nombre de classes variant entre 1 et 15.
inertie.intra<-sapply(1:15,
FUN=function(centers){
kmeans(res.pca$ind$coord,
centers = centers,
nstart = 100)$tot.withinss
}
)
barplot(inertie.intra,
names.arg = 1:15,
ylab = "inertie intra-classe",
xlab = "nombre de classes")
