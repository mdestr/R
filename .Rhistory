install.packages("devtools")
install.packages("ragg")
install.packages("ragg")
install.packages("devtools")
library("devtools")
devtools::install_github("abresler/nbastatR")
# https://rpubs.com/thecodingone/nbastatRTutorial
# Install and Load the nbastatR package
library('nbastatR')
# Access the game tables for a particular season
gamedata <- game_logs(seasons = 2025)
# https://rpubs.com/thecodingone/nbastatRTutorial
# Install and Load the nbastatR package
library('nbastatR')
Sys.setenv("VROOM_CONNECTION_SIZE" = 5000000)
# Access the game tables for a particular season
gamedata <- game_logs(seasons = 2025)
# Take a quick look at the data
head(gamedata)
all_nba_players <- get_nba_players_ids(league = "NBA",
active_only = T)
profiles_2015_season <-
get_season_player_profiles(year.season_start = 2014, include_headline_stats = T,
only_rostered_players = T,
message = T)
# https://rpubs.com/thecodingone/nbastatRTutorial
# Install and Load the nbastatR package
library('nbastatR')
Sys.setenv("VROOM_CONNECTION_SIZE" = 5000000)
all_nba_players <- get_nba_players_ids(league = "NBA",
active_only = T)
all_nba_players <- get_nba_players_ids(league = "NBA",
active_only = T)
profiles_2015_season <-
get_season_player_profiles(year.season_start = 2014, include_headline_stats = T,
only_rostered_players = T,
message = T)
profiles_2015_season <- nba_player_profiles(seasons = 2015)
get_bref_players_bios(players = NULL, player_ids = NULL,
assign_to_environment = TRUE, return_message = T)
get_bref_players_bios( players = c("Jarrett Allen", "Mitch Richmond", "Michael Adams"),
player_ids = NULL,
assign_to_environment = TRUE)
get_nba_players()
install.packages("hoopR")
library(hoopR)
# Ensuite pour récupérer des données :
data <- espn_nba_player_box(season = 2025)
# Ensuite pour récupérer des données :
data <- nba_player_box(season = 2025)
df_players <- players_careers(
players = NULL,  # Tous les joueurs
modes = c("PerGame", "Totals"),  # Stats par match et totals
seasons = 2024   # Saison 2023-24
)
df_players <- players_careers(
players = NULL,  # Tous les joueurs
modes = c("PerGame", "Totals"),  # Stats par match et totals
)
df_players <- players_careers(
players = "Lebron JAMES",  # Tous les joueurs
modes = c("PerGame", "Totals"),  # Stats par match et totals
)
df_players <- players_careers(
players = "Lebron James",  # Tous les joueurs
modes = c("PerGame", "Totals"),  # Stats par match et totals
)
player_profiles <- bref_players_profiles(seasons = 2024)
library('nbastatR')
player_profiles <- bref_players_profiles(seasons = 2024)
players_careers()
players_careers(NULL)
players_careers(players = c("Joe Harris", "Myles Turner", "Spencer Dinwiddie"),
modes = c("Totals", "PerGame"))
tictoc::tic()
nba_pbp <- hoopR::load_nba_pbp(2024:hoopR::most_recent_nba_season())
head nba_pbp
head(nba_pbp)
reticulate::repl_python()
reticulate::repl_python()
# Nikola Jokić
reticulate::repl_python()
career = playercareerstats.PlayerCareerStats(player_id='203999')
reticulate::repl_python()
from nba_api.stats.endpoints import playercareerstats
reticulate::repl_python()
pip install nba_api
reticulate::repl_python()
# Installer reticulate pour exécuter Python dans R
reticulate::repl_python()
install.packages("reticulate")
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::py_install("nba_api", pip = TRUE)
reticulate::repl_python()
library(reticulate)
reticulate::repl_python()
# Charger le module Python
reticulate::repl_python()
nba_api <- import("nba_api.stats.endpoints")
reticulate::repl_python()
# Fonction pour récupérer les stats d'un joueur
reticulate::repl_python()
get_nba_stats <- function(player_id) {
reticulate::repl_python()
career <- nba_api$playercareerstats$PlayerCareerStats(player_id = player_id)
reticulate::repl_python()
# Convertir en dataframe R
reticulate::repl_python()
df <- py_to_r(career$get_data_frames()[[1]])
reticulate::repl_python()
return(df)
reticulate::repl_python()
}
reticulate::repl_python()
# Exemple avec Nikola Jokic (ID: 203999)
reticulate::repl_python()
jokic_stats <- get_nba_stats('203999')
reticulate::repl_python()
# Afficher les statistiques
reticulate::repl_python()
head(jokic_stats)
reticulate::repl_python()
# Option : sauvegarder en CSV
reticulate::repl_python()
write.csv(jokic_stats, "jokic_career_stats.csv", row.names = FALSE)
reticulate::repl_python()
library(reticulate)
reticulate::repl_python()
# 1. Configurer Python (si ce n'est pas déjà fait)
reticulate::repl_python()
py_config() # Vérifie la configuration Python
reticulate::repl_python()
py_install("nba_api", pip = TRUE) # Installe le package si nécessaire
reticulate::repl_python()
# 2. Importer le module Python directement dans R
reticulate::repl_python()
nba_api <- import("nba_api.stats.endpoints")
reticulate::repl_python()
# 3. Créer une fonction R pour obtenir les stats
reticulate::repl_python()
get_nba_stats <- function(player_id) {
reticulate::repl_python()
career <- nba_api$playercareerstats$PlayerCareerStats(player_id = player_id)
reticulate::repl_python()
df <- py_to_r(career$get_data_frames()[[1]])
reticulate::repl_python()
return(df)
reticulate::repl_python()
}
reticulate::repl_python()
# 4. Utilisation avec Jokic
reticulate::repl_python()
jokic_stats <- get_nba_stats('203999')
reticulate::repl_python()
# 5. Afficher les résultats
reticulate::repl_python()
head(jokic_stats)
reticulate::repl_python()
# 6. Sauvegarder
reticulate::repl_python()
write.csv(jokic_stats, "jokic_career_stats.csv", row.names = FALSE)
# Créer la matrice
matrice_contingence <- matrix(c(9, 1, 0,
0, 7, 3,
0, 4, 6),
nrow = 3, byrow = TRUE,
dimnames = list(c("Sucré", "Acide", "Amer"),
c("Perçu sucré", "Perçu acide", "Perçu amer")))
# Afficher le résultat
print(matrice_contingence)
# Fréquences relatives par rapport au total général
freq_totale <- matrice_contingence / sum(matrice_contingence)
# Fréquences lignes (profil ligne)
freq_lignes <- prop.table(matrice_contingence, margin = 1)
# Fréquences colonnes (profil colonne)
freq_colonnes <- prop.table(matrice_contingence, margin = 2)
# Matrice originale
print("Tableau de contingence initial:")
print(matrice_contingence)
# Fréquences totales
print("\nFréquences relatives (total):")
print(round(freq_totale, 3))
# Profils lignes
print("\nProfils lignes (fréquences conditionnelles par stimulus):")
print(round(freq_lignes, 3))
# Profils colonnes
print("\nProfils colonnes (fréquences conditionnelles par perception):")
print(round(freq_colonnes, 3))
# Profils lignes
profils_lignes <- prop.table(matrice_contingence, margin=1)
# Profil marginal (gi)
gi <- colSums(matrice_contingence) / sum(matrice_contingence)  # (0.3, 0.4, 0.3)
# Vérifier que gi = moyenne pondérée des profils
weights <- rowSums(matrice_contingence) / sum(matrice_contingence)  # Poids (10/30, 10/30, 10/30)
all.equal(gi, colSums(profils_lignes * weights))  # Renvoie TRUE
# Profils lignes
profils_lignes <- prop.table(matrice_contingence, margin=1)
print(profils_lignes)
# Profil marginal (gi)
gi <- colSums(matrice_contingence) / sum(matrice_contingence)  # (0.3, 0.4, 0.3)
print(gi)
# Vérifier que gi = moyenne pondérée des profils
weights <- rowSums(matrice_contingence) / sum(matrice_contingence)  # Poids (10/30, 10/30, 10/30)
all.equal(gi, colSums(profils_lignes * weights))  # Renvoie TRUE
# Profils colonnes
profils_colonnes <- prop.table(M, margin=2)  # Chaque colonne divisée par son total
# Profil marginal colonne (Gⱼ)
GJ <- rowSums(M) / sum(M)  # (0.3, 0.4, 0.3)
# Vérification
print("Profil marginal colonne (Gⱼ):")
print(GJ)
# Créer la matrice
M <- matrix(c(9, 1, 0,
0, 7, 3,
0, 4, 6),
nrow = 3, byrow = TRUE,
dimnames = list(c("Sucré", "Acide", "Amer"),
c("Perçu sucré", "Perçu acide", "Perçu amer")))
# Afficher le résultat
print(M)
# Fréquences relatives par rapport au total général
freq_totale <- M / sum(M)
# Fréquences lignes (profil ligne)
freq_lignes <- prop.table(M, margin = 1)
# Fréquences colonnes (profil colonne)
freq_colonnes <- prop.table(M, margin = 2)
# Matrice originale
print("Tableau de contingence initial:")
print(M)
# Fréquences totales
print("\nFréquences relatives (total):")
print(round(freq_totale, 3))
# Profils lignes
print("\nProfils lignes (fréquences conditionnelles par stimulus):")
print(round(freq_lignes, 3))
# Profils colonnes
print("\nProfils colonnes (fréquences conditionnelles par perception):")
print(round(freq_colonnes, 3))
# Profils lignes
profils_lignes <- prop.table(M, margin=1)
print(profils_lignes)
# Profil marginal (gi)
gi <- colSums(M) / sum(M)  # (0.3, 0.4, 0.3)
print(gi)
# Vérifier que gi = moyenne pondérée des profils
weights <- rowSums(M) / sum(M)  # Poids (10/30, 10/30, 10/30)
all.equal(gi, colSums(profils_lignes * weights))  # Renvoie TRUE
# Profils colonnes
profils_colonnes <- prop.table(M, margin=2)  # Chaque colonne divisée par son total
# Profil marginal colonne (Gⱼ)
GJ <- rowSums(M) / sum(M)  # (0.3, 0.4, 0.3)
# Vérification
print("Profil marginal colonne (Gⱼ):")
print(GJ)
library(FactoMineR)
res.CA <- CA(M, graph=FALSE)
res.CA$eig  # Affiche l'inertie totale et par axe
reticulate::repl_python()
from basketball_reference_scraper.teams import get_roster, get_roster_stats
library(reticulate)
library(reticulate)
# 1. Charger et exécuter tout le script Python
source_python("./scrapnbaStats.py")
library(reticulate)
# 1. Charger et exécuter tout le script Python
source_python("./scrapnbaStats.py")
library(reticulate)
# 1. Charger et exécuter tout le script Python
source_python("./scrapnbaStats.py")
# Définir le répertoire de travail comme celui du script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(reticulate)
# 1. Charger et exécuter tout le script Python
source_python("./scrapnbaStats.py")
# Définir le répertoire de travail comme celui du script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
py_install("basketball-reference-scraper", pip = TRUE)
library(reticulate)
# 1. Charger et exécuter tout le script Python
source_python("./scrapnbaStats.py")
reticulate::py_last_error()
# Coordonnées des lignes (premier axe)
res.CA$row$coord[,1]  # Doit correspondre à F_1(i)
# Coordonnées des colonnes (premier axe)
res.CA$col$coord[,1]  # Doit correspondre à G_1(j)
