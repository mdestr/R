# Spearman
matcor.spear <- cor(nba[,quanti.cont],method = "spearman")
png("nba_matrice_corr_spearman.png", width = 1000, height = 1000)
PlotCorr(matcor.spear, cex.lab = par("cex.lab"), cex = 0.55)
dev.off()
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
library(BioStatR)
# calcul des différents eta carré
for(ii in seq(nrow(mateta2))){
for(jj in seq(ncol(mateta2))){
mateta2[ii, jj]<-eta2(data_hab_type[, colnames(mateta2)[jj]],
data_hab_type[, rownames(mateta2)[ii]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
library(BioStatR)
# calcul des différents eta carré
for(ii in seq(nrow(mateta2))){
for(jj in seq(ncol(mateta2))){
mateta2[ii, jj]<-eta2(nba[, colnames(mateta2)[jj]],
nba[, rownames(mateta2)[ii]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
mateta2
library(BioStatR)
# calcul des différents eta carré
for(ii in seq(nrow(mateta2))){
for(jj in seq(ncol(mateta2))){
mateta2[ii, jj]<-eta2(nba[, colnames(mateta2)[jj]],
nba[, rownames(mateta2)[ii]])
}
}
# calcul des différents eta carré
for(ii in seq(nrow(mateta2))){
for(jj in seq(ncol(mateta2))){
mateta2[ii, jj]<-eta2(nba[, colnames(mateta2)[jj]],
nba[, rownames(mateta2)[ii]])
}
}
mateta2
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- colnames(quali)
colnames(mateta2) <- colnames(quanti)
library(BioStatR)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
mateta2
library(BioStatR)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- colnames(quali)
colnames(mateta2) <- colnames(quanti)
mateta2
library(BioStatR)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- colnames(quali)
colnames(mateta2) <- colnames(quanti)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- colnames(nba)[quali]
colnames(mateta2) <- colnames(nba)[quanti]
mateta2
library(BioStatR)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
# Définir le répertoire de travail comme celui du script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# 1. Charger les données
nba <- read.table("./nba_players_stats_merged.csv",
header = TRUE,    # La première ligne contient les noms de colonnes
sep = "",         # Séparateur = espace
dec = ".",        # Point comme séparateur décimal
stringsAsFactors = TRUE)
########################
# Etude proprement dite #
########################
##########################################
# Sur le modèle de AFDM_data_logements.R #
##########################################
# 1. Charger les données
nba <- read.table("./nba_players_stats_merged.csv",
header = TRUE,    # La première ligne contient les noms de colonnes
sep = "",         # Séparateur = espace
dec = ".",        # Point comme séparateur décimal
stringsAsFactors = TRUE)
dim(nba)
# résumé univarié des données
head(nba)
summary(nba)
# Identification des variables selon leur type
quali <- names(Filter(is.factor, nba))
quali <- setdiff(quali, c("Player"))  # on enlève la colonne d'identification
quali
# Identification des variables selon leur type
quali <- which(sapply(data_hab_type, is.factor))
quali
########################
# Etude proprement dite #
########################
##########################################
# Sur le modèle de AFDM_data_logements.R #
##########################################
# 1. Charger les données
nba <- read.table("./nba_players_stats_merged.csv",
header = TRUE,    # La première ligne contient les noms de colonnes
sep = "",         # Séparateur = espace
dec = ".",        # Point comme séparateur décimal
stringsAsFactors = TRUE)
dim(nba)
# résumé univarié des données
head(nba)
summary(nba)
# Identification des variables selon leur type
quali <- which(sapply(nba, is.factor))
# quali <- names(Filter(is.factor, nba))
# quali <- setdiff(quali, c("Player"))  # on enlève la colonne d'identification
quali
# Identification des variables selon leur type
quali <- which(sapply(nba, is.factor))
quali <- quali[names(quali) != "Player"]
# quali <- names(Filter(is.factor, nba))
# quali <- setdiff(quali, c("Player"))  # on enlève la colonne d'identification
quali
quanti <- which(sapply(nba, is.numeric))
quanti.cont <- quanti[-quanti.discr]
quanti.fouls <- which(regexpr("FOUL", colnames(nba))>0)
head(quali)
head(quanti)
head(quanti.fouls)
# Analyses univariées
### Boxplots
# install.packages("car")
library(car)
mapply(nba[,quanti.cont],
FUN = function(xx,name){Boxplot(xx, main = name,id.n = 2, ylab = "")},
name = names(quanti.cont))
### Diagrammes en barres
par(mfrow = c(2, 3), mar = c(3, 3, 2, 1))  # Marges plus serrées
par(mfrow = c(2, 3))
mapply(nba[,quali],
FUN = function(xx,name){barplot(table(xx),main = name)},
name = names(quali))
### Tableaux
# quanti continu
# install.packages("stargazer")
library(stargazer)
stargazer(nba[,quanti.cont],
summary.stat = c("n","min","p25","median","mean","p75","max","sd"),
type = "text")
# quali
library(questionr)
univ_quali <- lapply(nba[,quali], freq)
univ_quali
# Analyses univariées
### lien entre variables quanti
# Pearson
# install.packages("DescTools")
library(DescTools)
matcor.pears <-cor(nba[,quanti.cont])
png("nba_matrice_corr_pearson.png", width = 1000, height = 1000)
PlotCorr(matcor.pears, cex.lab = par("cex.lab"), cex = 0.55)
dev.off()
# Spearman
matcor.spear <- cor(nba[,quanti.cont],method = "spearman")
png("nba_matrice_corr_spearman.png", width = 1000, height = 1000)
PlotCorr(matcor.spear, cex.lab = par("cex.lab"), cex = 0.55)
dev.off()
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
mateta2
library(BioStatR)
for(ii in seq_len(nrow(mateta2))){
for(jj in seq_len(ncol(mateta2))){
var_quali <- rownames(mateta2)[ii]
var_quanti <- colnames(mateta2)[jj]
print(paste("Calcul de eta2 entre", var_quanti, "et", var_quali))
mateta2[ii, jj] <- eta2(nba[[var_quanti]], nba[[var_quali]])
}
}
# affichage
png("nba_matrice_eta2.png", width = 1000, height = 1000)
PlotCorr(mateta2,
border = NA,
cols = colorRampPalette(c("white", "steelblue"), space = "rgb")(20),
breaks = seq(0, 1, length=21),
cex.lab = par("cex.lab"), cex = 0.55*par("cex"),
args.colorlegend = list(labels = sprintf("%.1f", seq(0, 1, length = 11)), frame = TRUE))
dev.off()
#identification des variables les plus liées aux variables de fautes, par ex FOUL_CHARGE
res.eta2<-sort(mateta2[,"FOUL_CHARGE"])
#représentation
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.names  =.35)
#représentation
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.names  =.35)
#identification des variables les plus liées aux variables de fautes, par ex FOUL_CHARGE
res.eta2<-sort(mateta2[,"FOUL_CHARGE"])
#représentation
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.names  =.35)
########################
# Etude proprement dite #
########################
##########################################
# Sur le modèle de AFDM_data_logements.R #
##########################################
# 1. Charger les données
nba <- read.table("./nba_players_stats_merged.csv",
header = TRUE,    # La première ligne contient les noms de colonnes
sep = "",         # Séparateur = espace
dec = ".",        # Point comme séparateur décimal
stringsAsFactors = TRUE)
dim(nba)
# résumé univarié des données
head(nba)
summary(nba)
# Identification des variables selon leur type
quali <- which(sapply(nba, is.factor))
quali <- quali[names(quali) != "Player"]
# quali <- names(Filter(is.factor, nba))
# quali <- setdiff(quali, c("Player"))  # on enlève la colonne d'identification
quali
quanti <- which(sapply(nba, is.numeric))
quanti.cont <- quanti[-quanti.discr]
quanti.fouls <- which(regexpr("FOUL", colnames(nba))>0)
head(quali)
head(quanti)
head(quanti.fouls)
# Analyses univariées
### Boxplots
# install.packages("car")
library(car)
mapply(nba[,quanti.cont],
FUN = function(xx,name){Boxplot(xx, main = name,id.n = 2, ylab = "")},
name = names(quanti.cont))
### Diagrammes en barres
par(mfrow = c(2, 3), mar = c(3, 3, 2, 1))  # Marges plus serrées
par(mfrow = c(2, 3))
mapply(nba[,quali],
FUN = function(xx,name){barplot(table(xx),main = name)},
name = names(quali))
### Tableaux
# quanti continu
# install.packages("stargazer")
library(stargazer)
stargazer(nba[,quanti.cont],
summary.stat = c("n","min","p25","median","mean","p75","max","sd"),
type = "text")
# quali
library(questionr)
univ_quali <- lapply(nba[,quali], freq)
univ_quali
# Analyses univariées
### lien entre variables quanti
# Pearson
# install.packages("DescTools")
library(DescTools)
matcor.pears <-cor(nba[,quanti.cont])
png("nba_matrice_corr_pearson.png", width = 1000, height = 1000)
PlotCorr(matcor.pears, cex.lab = par("cex.lab"), cex = 0.55)
dev.off()
# Spearman
matcor.spear <- cor(nba[,quanti.cont],method = "spearman")
png("nba_matrice_corr_spearman.png", width = 1000, height = 1000)
PlotCorr(matcor.spear, cex.lab = par("cex.lab"), cex = 0.55)
dev.off()
####lien entre variables quanti et quali
# creation d'une matrice vide avec en ligne les variables quantitatives et en colonne les variables qualitatives
mateta2 <- matrix(NA,length(quali),length(quanti))
rownames(mateta2) <- names(quali)
colnames(mateta2) <- names(quanti)
mateta2
library(BioStatR)
# calcul des différents eta carré
for(ii in seq(nrow(mateta2))){
for(jj in seq(ncol(mateta2))){
mateta2[ii, jj]<-eta2(nba[, colnames(mateta2)[jj]],
nba[, rownames(mateta2)[ii]])
}
}
# affichage
png("nba_matrice_eta2.png", width = 1000, height = 1000)
PlotCorr(mateta2,
border = NA,
cols = colorRampPalette(c("white", "steelblue"), space = "rgb")(20),
breaks = seq(0, 1, length=21),
cex.lab = par("cex.lab"), cex = 0.55*par("cex"),
args.colorlegend = list(labels = sprintf("%.1f", seq(0, 1, length = 11)), frame = TRUE))
dev.off()
#identification des variables les plus liées aux variables de fautes, par ex FOUL_CHARGE
res.eta2<-sort(mateta2[,"FOUL_CHARGE"])
#représentation
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.names  =.35)
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.names  =.35)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 0.8,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names  =.35)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 1.8,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names  =.35)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 3,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names  =.35)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 0.8,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names  =.8)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 0.8,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names = 1.5)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 0.8,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names = 1.1)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 1.5,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names = 1.1)
dev.off()
#représentation
png("nba_barplot.png", width = 1000, height = 1000)
barplot(res.eta2,horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = "Foul_charge",
cex.axis = 1.5,   # Taille de police des étiquettes (valeur par défaut = 1)
cex.names = 0.9)
dev.off()
# pour toutes les variables de fautes
mapply(as.data.frame(mateta2[,colnames(nba)[quanti.fouls]]),
FUN=function(xx,name){
names(xx) = rownames(mateta2)
res.eta2 <- sort(xx)
barplot(res.eta2,
horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = name,
xlim = c(0,1))
},
name = colnames(nba)[quanti.fouls])
# pour toutes les variables de fautes
png("nba_barplot_fouls.png", width = 1000, height = 1000)
mapply(as.data.frame(mateta2[,colnames(nba)[quanti.fouls]]),
FUN=function(xx,name){
names(xx) = rownames(mateta2)
res.eta2 <- sort(xx)
barplot(res.eta2,
horiz = TRUE,
las = 2,
xlab = expression(eta^2),
main = name,
xlim = c(0,1))
},
name = colnames(nba)[quanti.fouls])
dev.off()
install.packages("haven")
library(haven)
# Définir le répertoire de travail comme celui du script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Lire le fichier .sav
data <- read_sav("../Projet/MICS_Datasets/Ukraine\ 2012\ MICS_Datasets/Ukraine_MICS4_Datasets/Ukraine\ MICS\ 2012\ SPSS\ Datasets/2014 wm.sav")
# Lire le fichier .sav
data <- read_sav("./Projet/MICS_Datasets/Ukraine\ 2012\ MICS_Datasets/Ukraine_MICS4_Datasets/Ukraine\ MICS\ 2012\ SPSS\ Datasets/2014 wm.sav")
# Lire le fichier .sav
data <- read_sav("./Projet/MICS_Datasets/Ukraine2012_MICS_Datasets/Ukraine_MICS4_Datasets/Ukraine_MICS_2012_SPSS_Datasets/wm.sav")
# Lire le fichier .sav
data <- read_sav("../Projet/MICS_Datasets/Ukraine2012_MICS_Datasets/Ukraine_MICS4_Datasets/Ukraine_MICS_2012_SPSS_Datasets/wm.sav")
# Afficher les premières lignes
head(donnees)
# Afficher les premières lignes
head(data)
library(haven)
hl <- read_sav("~/Master_Cnam/STA101-Analyse des données méthodes descriptives/Projet/MICS_Datasets/Ukraine2012_MICS_Datasets/Ukraine_MICS4_Datasets/Ukraine_MICS_2012_SPSS_Datasets/hl.sav")
View(hl)
